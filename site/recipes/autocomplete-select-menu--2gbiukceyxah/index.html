<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Autocomplete Selection Menu - The HTML, CSS, and JavaScript Cookbook Of Alan</title>
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Autocomplete Selection Menu" />
    <meta property="og:description" content="An selection menu with autocompletion that only allows for the configure values to be selected" />
    <meta
      property="og:image"
      content="https://res.cloudinary.com/awsimages/image/upload/w_1200,h_630/c_fit,co_rgb:222222,l_text:Helvetica_72_bold:Autocomplete%20Selection%20Menu,w_1080,h_480/fl_layer_apply,g_north_west,x_70,y_70/og-images/html-css-js--og-2022-10-24-blank.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site:id" content="@TheIdOfAlan" />
    <meta name="twitter:creator" content="@TheIdOfAlan" />
    <link
      rel="icon"
      type="image/png"
      sizes="228x228"
      href="/favicons/228x228.png"
    />
    <link
      rel="apple-touch-icon-precomposed"
      sizes="180x180"
      href="/favicons/180x180.png"
    />
    <link rel="stylesheet" href="/styles/global.css" />
    <link rel="stylesheet" href="/styles/prism.css" />
    
    <style>
      #awsselectmenu--search-text {
    background-color: white;
    height: 1.4rem;
    padding: 4px;
    color: black;
}

    </style>
    <script>
      const options = [
    { key: 'roboto', value: 'Roboto' },
    { key: 'opensans', value: 'OpenSans' },
    { key: 'montserrat', value: 'Montserrat' },
    { key: 'lato', value: 'Lato' },
    { key: 'poppins', value: 'Poppins' },
    { key: 'sourcesanspro', value: 'Source Sans Pro' },
    { key: 'robotocondensed', value: 'Roboto Condensed' },
    { key: 'oswald', value: 'Oswald' },
    { key: 'robotomono', value: 'Roboto Mono' },
    { key: 'raleway', value: 'Raleway' },
    { key: 'inter', value: 'Inter' },
    { key: 'notosans', value: 'Noto Sans' },
    { key: 'ubuntu', value: 'Ubuntu' },
    { key: 'mukta', value: 'Mukta' },
    { key: 'robotoslab', value: 'Roboto Slab' },
    { key: 'nunito', value: 'Nunito' },
    { key: 'playfairdisplay', value: 'Playfair Display' },
    { key: 'ptsans', value: 'PT Sans' },
    { key: 'nunitosans', value: 'Nunito Sans' },
    { key: 'merriweather', value: 'Merriweather' },
    { key: 'rubik', value: 'Rubik' },
    { key: 'notosanskr', value: 'Noto Sans KR' },
    { key: 'worksans', value: 'Work Sans' },
    { key: 'lora', value: 'Lora' },
    { key: 'firasans', value: 'Fira Sans' },
]

// const fullList = []
// const fullKeys = {}
// const currentList = []

// TODO: Move stuff into this:
const state = {
    activeKey: null,
    // fullList: [],
    fullKeys: {},
    // currentList: [],
}

const prepKeys = () => {
    options.forEach((option) => {
        state.fullKeys[option.key] = option.value
    })
}

const handleInputFocus = (event) => {
    event.target.innerText = ''
    const selectionsEl = document.getElementById('awsselectmenu--selections')
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    for (let i = 0; i < 5; i++) {
        const newItem = document.createElement('button')
        const buttonId = `awsselectmenu--choice-id--${options[i].key}`
        newItem.id = buttonId
        newItem.innerHTML = options[i].value
        selectionsEl.appendChild(newItem)
    }
}

// const handleButtonClick = (event) => {
//     console.log('click')
//     const selectionsEl = document.getElementById('selectionsWrapper')
//     while (selectionsEl.firstChild) {
//         selectionsEl.removeChild(selectionsEl.firstChild)
//     }
//     const parts = event.target.id.split('--')
//     console.log(parts)
//     // state.activeSelection = fullKeys[parts[1]]
//     // console.log(state.activeSelection)
//     // document.getElementById(
//     //     'active-selection'
//     // ).innerText = `Active Selection: ${state.activeSelection}`
//     // // document.getElementById('selection-text-field').innerText =
//     //     state.activeSelection
// }

// const handleButtonFocus = () => {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
// }

// const handleButtonBlur = () => {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
//     timeoutIdForBlurTransition = setTimeout(() => {
//         const selectionsEl = document.getElementById('selectionsWrapper')
//         while (selectionsEl.firstChild) {
//             selectionsEl.removeChild(selectionsEl.firstChild)
//         }
//     }, 30)
// }

// // This closes things if you don't tab over to a button
// // Setting time timeout at 30ms was too fast. The
// // buttons closed before the click registered.
// const handleInputBlur = () => {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
//     timeoutIdForBlurTransition = setTimeout(() => {
//         const selectionsEl = document.getElementById('selectionsWrapper')
//         while (selectionsEl.firstChild) {
//             selectionsEl.removeChild(selectionsEl.firstChild)
//         }
//         document.getElementById(
//             'active-selection'
//         ).innerText = `Active Selection: ${state.activeSelection}`
//     }, 150)
// }

const makeSelection = () => {
    // TODO: deal with if there isn't a valid option
    console.log('Making selection')
    const theInput = document.getElementById('selection-text-field')
    console.log(theInput.innerText)
    theInput.innerText = ''
}

const handleKeyup = (event) => {
    // TODO: Handle tab and escape
    const pressedKey = event.key.toLowerCase()
    if (pressedKey === 'enter') {
        console.log('ENTER')
        // makeSelection()
    } else {
        state.currentSearch = document.getElementById(
            'awsselectmenu--search-text'
        ).innerText
        removeSelections()
        const selectionsEl = document.getElementById(
            'awsselectmenu--selections'
        )
        let counter = 0
        for (i = 0; i < options.length; i++) {
            const pattern = new RegExp(state.currentSearch, 'gi')
            if (options[i].value.toLowerCase().match(pattern)) {
                const newItem = document.createElement('button')
                const buttonId = `awsselectmenu--choice-id--${options[i].key}`
                newItem.id = buttonId
                newItem.innerHTML = options[i].value
                selectionsEl.appendChild(newItem)
                counter += 1
            }
            if (counter === 5) {
                break
            }
        }
        console.log(state.currentSearch)
    }
}

const removeSelections = () => {
    const selectionsEl = document.getElementById('awsselectmenu--selections')
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
}

const setSelectionFromKey = (key) => {
    state.activeKey = key
    console.log(state.activeKey)
    removeSelections()
    setPlaceholder()
}

const setPlaceholder = () => {
    const inputField = document.getElementById('awsselectmenu--search-text')
    if (state.activeKey) {
        inputField.innerText = state.fullKeys[state.activeKey]
    } else {
        inputField.innerText = 'Select a font'
    }
}

// This is here to deal with clicking away from
// the input field so it can be closed without
// haveing to set a timer to keep the buttons from
// closing for a bit before they disappear
const handlePageClick = (event) => {
    const clickId = event.target.id
    if (clickId) {
        const idParts = clickId.split('--')
        if (idParts[0] !== 'awsselectmenu') {
            removeSelections()
        } else {
            if (idParts[1] === 'choice-id') {
                setSelectionFromKey(idParts[2])
            }
        }
    } else {
        removeSelections()
    }
}

const kickoff = () => {
    console.log(`Kickoff: ${new Date().getTime()}`)
    prepKeys()
    document
        .getElementById('awsselectmenu--search-text')
        .addEventListener('focus', handleInputFocus)

    // document
    //     .getElementById('selection-text-field')
    //     .addEventListener('blur', handleInputBlur)

    document
        .getElementById('awsselectmenu--search-text')
        .addEventListener('keyup', handleKeyup)

    // document
    //     .getElementById('selectionsWrapper')
    //     .addEventListener('click', handleButtonClick)

    document.addEventListener('click', handlePageClick)
    setPlaceholder()
}

document.addEventListener('DOMContentLoaded', kickoff)

    </script>
  </head>
  <body class="line-numbers">

    <header>
      <a href="/">Cookbook Home</a> ~
      <a href="https://www.alanwsmith.com/">alanwsmith.com</a> ~
      <a href="https://links.alanwsmith.com">links</a> ~
      <a href="https://podcast.alanwsmith.com/">podcast</a>
    </header>

    <main>
      <h1>Autocomplete Select Menu</h1>
      <p>This is a work in progress. (aka: it doesn't work yet)</p>
      <div id="tmp-focus-target-for-safari-fix"></div>

      <div
  autocomplete="off"
  spellcheck="false"
  id="awsselectmenu--search-text"
  contenteditable="true"
></div>
<div id="awsselectmenu--selections"></div>

<div id="awsselectmenu--current-selection">Active Selection: None</div>


       
            <h2>HTML</h2>
            <pre><code class="language-html">&lt;div
  autocomplete=&quot;off&quot;
  spellcheck=&quot;false&quot;
  id=&quot;awsselectmenu--search-text&quot;
  contenteditable=&quot;true&quot;
&gt;&lt;/div&gt;
&lt;div id=&quot;awsselectmenu--selections&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;awsselectmenu--current-selection&quot;&gt;Active Selection: None&lt;/div&gt;
</code></pre>
             
            <h2>CSS</h2>
            <pre><code class="language-css">#awsselectmenu--search-text {
    background-color: white;
    height: 1.4rem;
    padding: 4px;
    color: black;
}
</code></pre>
             
            <h2>JavaScript</h2>
            <pre><code class="language-js">const options = [
    { key: &#x27;roboto&#x27;, value: &#x27;Roboto&#x27; },
    { key: &#x27;opensans&#x27;, value: &#x27;OpenSans&#x27; },
    { key: &#x27;montserrat&#x27;, value: &#x27;Montserrat&#x27; },
    { key: &#x27;lato&#x27;, value: &#x27;Lato&#x27; },
    { key: &#x27;poppins&#x27;, value: &#x27;Poppins&#x27; },
    { key: &#x27;sourcesanspro&#x27;, value: &#x27;Source Sans Pro&#x27; },
    { key: &#x27;robotocondensed&#x27;, value: &#x27;Roboto Condensed&#x27; },
    { key: &#x27;oswald&#x27;, value: &#x27;Oswald&#x27; },
    { key: &#x27;robotomono&#x27;, value: &#x27;Roboto Mono&#x27; },
    { key: &#x27;raleway&#x27;, value: &#x27;Raleway&#x27; },
    { key: &#x27;inter&#x27;, value: &#x27;Inter&#x27; },
    { key: &#x27;notosans&#x27;, value: &#x27;Noto Sans&#x27; },
    { key: &#x27;ubuntu&#x27;, value: &#x27;Ubuntu&#x27; },
    { key: &#x27;mukta&#x27;, value: &#x27;Mukta&#x27; },
    { key: &#x27;robotoslab&#x27;, value: &#x27;Roboto Slab&#x27; },
    { key: &#x27;nunito&#x27;, value: &#x27;Nunito&#x27; },
    { key: &#x27;playfairdisplay&#x27;, value: &#x27;Playfair Display&#x27; },
    { key: &#x27;ptsans&#x27;, value: &#x27;PT Sans&#x27; },
    { key: &#x27;nunitosans&#x27;, value: &#x27;Nunito Sans&#x27; },
    { key: &#x27;merriweather&#x27;, value: &#x27;Merriweather&#x27; },
    { key: &#x27;rubik&#x27;, value: &#x27;Rubik&#x27; },
    { key: &#x27;notosanskr&#x27;, value: &#x27;Noto Sans KR&#x27; },
    { key: &#x27;worksans&#x27;, value: &#x27;Work Sans&#x27; },
    { key: &#x27;lora&#x27;, value: &#x27;Lora&#x27; },
    { key: &#x27;firasans&#x27;, value: &#x27;Fira Sans&#x27; },
]

// const fullList = []
// const fullKeys = {}
// const currentList = []

// TODO: Move stuff into this:
const state = {
    activeKey: null,
    // fullList: [],
    fullKeys: {},
    // currentList: [],
}

const prepKeys = () =&gt; {
    options.forEach((option) =&gt; {
        state.fullKeys[option.key] = option.value
    })
}

const handleInputFocus = (event) =&gt; {
    event.target.innerText = &#x27;&#x27;
    const selectionsEl = document.getElementById(&#x27;awsselectmenu--selections&#x27;)
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    for (let i = 0; i &lt; 5; i++) {
        const newItem = document.createElement(&#x27;button&#x27;)
        const buttonId = `awsselectmenu--choice-id--${options[i].key}`
        newItem.id = buttonId
        newItem.innerHTML = options[i].value
        selectionsEl.appendChild(newItem)
    }
}

// const handleButtonClick = (event) =&gt; {
//     console.log(&#x27;click&#x27;)
//     const selectionsEl = document.getElementById(&#x27;selectionsWrapper&#x27;)
//     while (selectionsEl.firstChild) {
//         selectionsEl.removeChild(selectionsEl.firstChild)
//     }
//     const parts = event.target.id.split(&#x27;--&#x27;)
//     console.log(parts)
//     // state.activeSelection = fullKeys[parts[1]]
//     // console.log(state.activeSelection)
//     // document.getElementById(
//     //     &#x27;active-selection&#x27;
//     // ).innerText = `Active Selection: ${state.activeSelection}`
//     // // document.getElementById(&#x27;selection-text-field&#x27;).innerText =
//     //     state.activeSelection
// }

// const handleButtonFocus = () =&gt; {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
// }

// const handleButtonBlur = () =&gt; {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
//     timeoutIdForBlurTransition = setTimeout(() =&gt; {
//         const selectionsEl = document.getElementById(&#x27;selectionsWrapper&#x27;)
//         while (selectionsEl.firstChild) {
//             selectionsEl.removeChild(selectionsEl.firstChild)
//         }
//     }, 30)
// }

// // This closes things if you don&#x27;t tab over to a button
// // Setting time timeout at 30ms was too fast. The
// // buttons closed before the click registered.
// const handleInputBlur = () =&gt; {
//     if (timeoutIdForBlurTransition) {
//         clearTimeout(timeoutIdForBlurTransition)
//     }
//     timeoutIdForBlurTransition = setTimeout(() =&gt; {
//         const selectionsEl = document.getElementById(&#x27;selectionsWrapper&#x27;)
//         while (selectionsEl.firstChild) {
//             selectionsEl.removeChild(selectionsEl.firstChild)
//         }
//         document.getElementById(
//             &#x27;active-selection&#x27;
//         ).innerText = `Active Selection: ${state.activeSelection}`
//     }, 150)
// }

const makeSelection = () =&gt; {
    // TODO: deal with if there isn&#x27;t a valid option
    console.log(&#x27;Making selection&#x27;)
    const theInput = document.getElementById(&#x27;selection-text-field&#x27;)
    console.log(theInput.innerText)
    theInput.innerText = &#x27;&#x27;
}

const handleKeyup = (event) =&gt; {
    // TODO: Handle tab and escape
    const pressedKey = event.key.toLowerCase()
    if (pressedKey === &#x27;enter&#x27;) {
        console.log(&#x27;ENTER&#x27;)
        // makeSelection()
    } else {
        state.currentSearch = document.getElementById(
            &#x27;awsselectmenu--search-text&#x27;
        ).innerText
        removeSelections()
        const selectionsEl = document.getElementById(
            &#x27;awsselectmenu--selections&#x27;
        )
        let counter = 0
        for (i = 0; i &lt; options.length; i++) {
            const pattern = new RegExp(state.currentSearch, &#x27;gi&#x27;)
            if (options[i].value.toLowerCase().match(pattern)) {
                const newItem = document.createElement(&#x27;button&#x27;)
                const buttonId = `awsselectmenu--choice-id--${options[i].key}`
                newItem.id = buttonId
                newItem.innerHTML = options[i].value
                selectionsEl.appendChild(newItem)
                counter += 1
            }
            if (counter === 5) {
                break
            }
        }
        console.log(state.currentSearch)
    }
}

const removeSelections = () =&gt; {
    const selectionsEl = document.getElementById(&#x27;awsselectmenu--selections&#x27;)
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
}

const setSelectionFromKey = (key) =&gt; {
    state.activeKey = key
    console.log(state.activeKey)
    removeSelections()
    setPlaceholder()
}

const setPlaceholder = () =&gt; {
    const inputField = document.getElementById(&#x27;awsselectmenu--search-text&#x27;)
    if (state.activeKey) {
        inputField.innerText = state.fullKeys[state.activeKey]
    } else {
        inputField.innerText = &#x27;Select a font&#x27;
    }
}

// This is here to deal with clicking away from
// the input field so it can be closed without
// haveing to set a timer to keep the buttons from
// closing for a bit before they disappear
const handlePageClick = (event) =&gt; {
    const clickId = event.target.id
    if (clickId) {
        const idParts = clickId.split(&#x27;--&#x27;)
        if (idParts[0] !== &#x27;awsselectmenu&#x27;) {
            removeSelections()
        } else {
            if (idParts[1] === &#x27;choice-id&#x27;) {
                setSelectionFromKey(idParts[2])
            }
        }
    } else {
        removeSelections()
    }
}

const kickoff = () =&gt; {
    console.log(`Kickoff: ${new Date().getTime()}`)
    prepKeys()
    document
        .getElementById(&#x27;awsselectmenu--search-text&#x27;)
        .addEventListener(&#x27;focus&#x27;, handleInputFocus)

    // document
    //     .getElementById(&#x27;selection-text-field&#x27;)
    //     .addEventListener(&#x27;blur&#x27;, handleInputBlur)

    document
        .getElementById(&#x27;awsselectmenu--search-text&#x27;)
        .addEventListener(&#x27;keyup&#x27;, handleKeyup)

    // document
    //     .getElementById(&#x27;selectionsWrapper&#x27;)
    //     .addEventListener(&#x27;click&#x27;, handleButtonClick)

    document.addEventListener(&#x27;click&#x27;, handlePageClick)
    setPlaceholder()
}

document.addEventListener(&#x27;DOMContentLoaded&#x27;, kickoff)
</code></pre>
             
                <h2>Deatils</h2>
                <ul>
                    <li>GOAL: [ ] Accepts an array of key-value pairs to use as selections</li> <li>GOAL: [ ] Filter selections based on text input</li> <li>GOAL: [ ] Proper accessability</li> <li>GOAL: [ ] Show autocompete when typing</li> <li>GOAL: [ ] Show first option in text area if autocomplete doesn't match exactly</li> <li>GOAL: [ ] Clicking enter selects first item</li> <li>GOAL: [ ] Tabbing to secondary selections</li> <li>GOAL: [ ] Hitting enter on a secondary selection chooses it</li> <li>GOAL: [ ] Clicking a secondary button selects it</li> <li>GOAL: [ ] Show the last select item as a placeholder when the field isn't focused</li> <li>GOAL: [ ] Ability to select a placeholder on load</li> <li>GOAL: [ ] Scrollable list of selections</li> <li>GOAL: [ ] Multiple instances on the same page</li>
                </ul>
                 
                <h2>Notes</h2>
                <ul>
                    <li>This is currnelyt a very naive approach to the matching selections. If the string in the input field matches anywhere in the item list it gets included.</li>
                </ul>
             
                <h2>TODO</h2>
                <ul>
                    <li>Dig through this for multiline suppression: https://stackoverflow.com/questions/6831482/contenteditable-single-line-input</li>
                </ul>
             
                <h2>References</h2>
                <ul>
                    <li><a href=""></a></li>
                </ul>
                

    </main>
    <footer>
      made by <a href="https://twitter.com/TheIdOfAlan">
      <br />
      who has a <a href="https://www.alanwsmith.com">website</a> and a
      <a href="https://podcast.alanwsmith.com/">podcast</a> <br />
      among other <a href="https://links.alanwsmith.com">things</a>
    </footer>
    <script src="/styles/prism.js"></script>
  </body>
</html>
