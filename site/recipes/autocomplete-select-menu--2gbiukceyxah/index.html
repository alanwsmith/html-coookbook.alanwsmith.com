<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Autocomplete Selection Menu - The HTML, CSS, and JavaScript Cookbook Of Alan</title>
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Autocomplete Selection Menu" />
    <meta property="og:description" content="An selection menu with autocompletion that only allows for the configure values to be selected" />
    <meta
      property="og:image"
      content="https://res.cloudinary.com/awsimages/image/upload/w_1200,h_630/c_fit,co_rgb:222222,l_text:Helvetica_72_bold:Autocomplete%20Selection%20Menu,w_1080,h_480/fl_layer_apply,g_north_west,x_70,y_70/og-images/html-css-js--og-2022-10-24-blank.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site:id" content="@TheIdOfAlan" />
    <meta name="twitter:creator" content="@TheIdOfAlan" />
    <link
      rel="icon"
      type="image/png"
      sizes="228x228"
      href="/favicons/228x228.png"
    />
    <link
      rel="apple-touch-icon-precomposed"
      sizes="180x180"
      href="/favicons/180x180.png"
    />
    <link rel="stylesheet" href="/styles/global.css" />
    <link rel="stylesheet" href="/styles/prism.css" />
    
    <style>
      #selection-text-field {
    background-color: white;
    height: 1.4rem;
    padding: 4px;
    color: black;
}

    </style>
    <script>
      const options = [
    { key: 'roboto', value: 'Roboto' },
    { key: 'opensans', value: 'OpenSans' },
    { key: 'montserrat', value: 'Montserrat' },
    { key: 'lato', value: 'Lato' },
    { key: 'poppins', value: 'Poppins' },
    { key: 'sourcesanspro', value: 'Source Sans Pro' },
    { key: 'robotocondensed', value: 'Roboto Condensed' },
    { key: 'oswald', value: 'Oswald' },
    { key: 'robotomono', value: 'Roboto Mono' },
    { key: 'raleway', value: 'Raleway' },
    { key: 'inter', value: 'Inter' },
    { key: 'notosans', value: 'Noto Sans' },
    { key: 'ubuntu', value: 'Ubuntu' },
    { key: 'mukta', value: 'Mukta' },
    { key: 'robotoslab', value: 'Roboto Slab' },
    { key: 'nunito', value: 'Nunito' },
    { key: 'playfairdisplay', value: 'Playfair Display' },
    { key: 'ptsans', value: 'PT Sans' },
    { key: 'nunitosans', value: 'Nunito Sans' },
    { key: 'merriweather', value: 'Merriweather' },
    { key: 'rubik', value: 'Rubik' },
    { key: 'notosanskr', value: 'Noto Sans KR' },
    { key: 'worksans', value: 'Work Sans' },
    { key: 'lora', value: 'Lora' },
    { key: 'firasans', value: 'Fira Sans' },
]

let timeoutIdForBlurTransition = null

const fullList = []
const fullKeys = {}
const currentList = []

let state = {
    activeSelection: '',
}

// let activeFont = ''

// // Setup ids for each item
// const prepIds = () => {
//     for (const rawItem of rawItems) {
//         const itemId = rawItem.toLowerCase().replaceAll(/ /g, '')
//         fullList.push({
//             id: itemId,
//             name: rawItem,
//         })
//         fullKeys[itemId] = rawItem
//     }
// }

// const clearItems = () => {
//     // Clear any existing items
//     let itemWrapper = document.getElementById('menuItems')
//     while (itemWrapper.firstChild) {
//         console.log('x')
//         itemWrapper.removeChild(itemWrapper.firstChild)
//     }
// }

// const updateItems = (filter) => {
//     // Get the wrapper
//     let itemWrapper = document.getElementById('menuItems')
//     // Clear any existing items
//     activeList.length = 0
//     while (itemWrapper.firstChild) {
//         console.log('x')
//         itemWrapper.removeChild(itemWrapper.firstChild)
//     }
//     // Only add items if there's a filter
//     if (filter) {
//         const pattern = new RegExp(filter, 'gi')
//         listIds.forEach((item) => {
//             const compareItem = item.name.toLowerCase()
//             if (item.name.toLowerCase().match(pattern)) {
//                 activeList.push(item)
//             }
//         })
//     }
//     // Output zero or more things
//     const itemCount = Math.min(5, activeList.length)
//     for (let i = 0; i < itemCount; i++) {
//         const newItem = document.createElement('button')
//         newItem.id = `item--${activeList[i].id}`
//         newItem.innerHTML = activeList[i].name
//         itemWrapper.appendChild(newItem)
//     }
// }

// const handleMenuClick = (event) => {
//     console.log(event.target.id)
//     idParts = event.target.id.split('--')
//     for (const listItem of listIds) {
//         if (idParts[1] === listItem.id) {
//             setActiveItem(listItem.name)
//             updateItems()
//         }
//     }
//     // updateItems(null)
//     // document.getElementById('font-input-field').contentEditable = false
//     // document.getElementById('font-input-field').contentEditable = true
//     // document.getElementById('test-focus-target').focus()
//     // document.getElementById('font-input-field').blur()
// }

// const handleMenuInput = (event) => {
//     console.log(event)
//     const textFilter = document
//         .getElementById('font-input-field')
//         .innerText.trim()
//     updateItems(textFilter)
// }

// const setActiveItem = (itemName) => {
//     console.log(`The new item is: ${itemName}`)
//     document.getElementById('active-font').innerText = itemName
//     document.getElementById('font-input-field').innerText = itemName
//     activeList.length = 0
//     activeFont = itemName
//     // See this: for the bounce here to fix the safari bug about
//     // things not bluring
//     document.getElementById('font-input-field').blur()
//     document.getElementById(
//         'tmp-focus-target-for-safari-fix'
//     ).contentEditable = true
//     document.getElementById('tmp-focus-target-for-safari-fix').focus()
//     document.getElementById('tmp-focus-target-for-safari-fix').blur()
//     document.getElementById(
//         'tmp-focus-target-for-safari-fix'
//     ).contentEditable = false
// }

// const handleKeyUp = (event) => {
//     // TODO: Handle escape
//     // TODO: Handle arrow keys
//     if (event.key.toLowerCase() === 'enter') {
//         console.log('Caught enter')
//         if (activeList[0]) {
//             setActiveItem(activeList[0].name)
//             updateItems()
//         }
//         document.getElementById('font-input-field').innerText = document
//             .getElementById('font-input-field')
//             .innerText.replaceAll(/\n/g, '')
//     }
// }

const handleInputFocus = (event) => {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    event.target.innerText = ''
    const selectionsEl = document.getElementById('selections')
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    for (let i = 0; i < 5; i++) {
        const newItem = document.createElement('button')
        newItem.id = `option--${options[i].key}`
        newItem.innerHTML = options[i].value
        newItem.className = 'option--button'
        newItem.addEventListener('focus', handleButtonFocus)
        newItem.addEventListener('blur', handleButtonBlur)
        newItem.addEventListener('click', handleButtonClick)
        selections.appendChild(newItem)
    }
}

const handleButtonClick = (event) => {
    const selectionsEl = document.getElementById('selections')
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    const parts = event.target.id.split('--')
    state.activeSelection = fullKeys[parts[1]]
    console.log(state.activeSelection)
    document.getElementById(
        'active-selection'
    ).innerText = `Active Selection: ${state.activeSelection}`
    document.getElementById('selection-text-field').innerText =
        state.activeSelection
}

const handleButtonFocus = () => {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
}

const handleButtonBlur = () => {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    timeoutIdForBlurTransition = setTimeout(() => {
        const selectionsEl = document.getElementById('selections')
        while (selectionsEl.firstChild) {
            selectionsEl.removeChild(selectionsEl.firstChild)
        }
    }, 30)
}

const handleInputBlur = () => {
    console.log('-- Input blur')
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    timeoutIdForBlurTransition = setTimeout(() => {
        const selectionsEl = document.getElementById('selections')
        while (selectionsEl.firstChild) {
            selectionsEl.removeChild(selectionsEl.firstChild)
        }
        document.getElementById(
            'active-selection'
        ).innerText = `Active Selection: ${state.activeSelection}`
    }, 30)
}

// const handleBlur = (event) => {
//     event.target.innerText = activeFont
//     // if (timeoutIdFixForBlur) {
//     //     clearTimeout(timeoutIdFixForBlur)
//     // }
//     // timeoutIdFixForBlur = setTimeout(() => {
//     //     event.target.innerText = activeFont
//     //     let itemWrapper = document.getElementById('menuItems')
//     //     while (itemWrapper.firstChild) {
//     //         console.log('x')
//     //         itemWrapper.removeChild(itemWrapper.firstChild)
//     //     }
//     // }, 100)
// }

const kickoff = () => {
    console.log(`Kickoff: ${new Date().getTime()}`)
    // prepIds()
    document
        .getElementById('selection-text-field')
        .addEventListener('focus', handleInputFocus)
    document
        .getElementById('selection-text-field')
        .addEventListener('blur', handleInputBlur)

    // document
    //     .getElementById('menuItems')
    //     .addEventListener('click', handleMenuClick)
    // document
    //     .getElementById('menuWrapper')
    //     .addEventListener('input', handleMenuInput)
    // document
    //     .getElementById('menuWrapper')
    //     .addEventListener('keyup', handleKeyUp)

    // updateItems()
}

document.addEventListener('DOMContentLoaded', kickoff)

    </script>
  </head>
  <body class="line-numbers">

    <header>
      <a href="/">Cookbook Home</a> ~
      <a href="https://www.alanwsmith.com/">alanwsmith.com</a> ~
      <a href="https://links.alanwsmith.com">links</a> ~
      <a href="https://podcast.alanwsmith.com/">podcast</a>
    </header>

    <main>
      <h1>Autocomplete Select Menu</h1>
      <p>This is a work in progress. (aka: it doesn't work yet)</p>
      <div id="tmp-focus-target-for-safari-fix"></div>

      <div id="active-selection">Active Selection: None</div>
<div id="selection-text-field" contenteditable="true"></div>
<div id="selections"></div>


       
            <h2>HTML</h2>
            <pre><code class="language-html">&lt;div id=&quot;active-selection&quot;&gt;Active Selection: None&lt;/div&gt;
&lt;div id=&quot;selection-text-field&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;selections&quot;&gt;&lt;/div&gt;
</code></pre>
             
            <h2>CSS</h2>
            <pre><code class="language-css">#selection-text-field {
    background-color: white;
    height: 1.4rem;
    padding: 4px;
    color: black;
}
</code></pre>
             
            <h2>JavaScript</h2>
            <pre><code class="language-js">const options = [
    { key: &#x27;roboto&#x27;, value: &#x27;Roboto&#x27; },
    { key: &#x27;opensans&#x27;, value: &#x27;OpenSans&#x27; },
    { key: &#x27;montserrat&#x27;, value: &#x27;Montserrat&#x27; },
    { key: &#x27;lato&#x27;, value: &#x27;Lato&#x27; },
    { key: &#x27;poppins&#x27;, value: &#x27;Poppins&#x27; },
    { key: &#x27;sourcesanspro&#x27;, value: &#x27;Source Sans Pro&#x27; },
    { key: &#x27;robotocondensed&#x27;, value: &#x27;Roboto Condensed&#x27; },
    { key: &#x27;oswald&#x27;, value: &#x27;Oswald&#x27; },
    { key: &#x27;robotomono&#x27;, value: &#x27;Roboto Mono&#x27; },
    { key: &#x27;raleway&#x27;, value: &#x27;Raleway&#x27; },
    { key: &#x27;inter&#x27;, value: &#x27;Inter&#x27; },
    { key: &#x27;notosans&#x27;, value: &#x27;Noto Sans&#x27; },
    { key: &#x27;ubuntu&#x27;, value: &#x27;Ubuntu&#x27; },
    { key: &#x27;mukta&#x27;, value: &#x27;Mukta&#x27; },
    { key: &#x27;robotoslab&#x27;, value: &#x27;Roboto Slab&#x27; },
    { key: &#x27;nunito&#x27;, value: &#x27;Nunito&#x27; },
    { key: &#x27;playfairdisplay&#x27;, value: &#x27;Playfair Display&#x27; },
    { key: &#x27;ptsans&#x27;, value: &#x27;PT Sans&#x27; },
    { key: &#x27;nunitosans&#x27;, value: &#x27;Nunito Sans&#x27; },
    { key: &#x27;merriweather&#x27;, value: &#x27;Merriweather&#x27; },
    { key: &#x27;rubik&#x27;, value: &#x27;Rubik&#x27; },
    { key: &#x27;notosanskr&#x27;, value: &#x27;Noto Sans KR&#x27; },
    { key: &#x27;worksans&#x27;, value: &#x27;Work Sans&#x27; },
    { key: &#x27;lora&#x27;, value: &#x27;Lora&#x27; },
    { key: &#x27;firasans&#x27;, value: &#x27;Fira Sans&#x27; },
]

let timeoutIdForBlurTransition = null

const fullList = []
const fullKeys = {}
const currentList = []

let state = {
    activeSelection: &#x27;&#x27;,
}

// let activeFont = &#x27;&#x27;

// // Setup ids for each item
// const prepIds = () =&gt; {
//     for (const rawItem of rawItems) {
//         const itemId = rawItem.toLowerCase().replaceAll(/ /g, &#x27;&#x27;)
//         fullList.push({
//             id: itemId,
//             name: rawItem,
//         })
//         fullKeys[itemId] = rawItem
//     }
// }

// const clearItems = () =&gt; {
//     // Clear any existing items
//     let itemWrapper = document.getElementById(&#x27;menuItems&#x27;)
//     while (itemWrapper.firstChild) {
//         console.log(&#x27;x&#x27;)
//         itemWrapper.removeChild(itemWrapper.firstChild)
//     }
// }

// const updateItems = (filter) =&gt; {
//     // Get the wrapper
//     let itemWrapper = document.getElementById(&#x27;menuItems&#x27;)
//     // Clear any existing items
//     activeList.length = 0
//     while (itemWrapper.firstChild) {
//         console.log(&#x27;x&#x27;)
//         itemWrapper.removeChild(itemWrapper.firstChild)
//     }
//     // Only add items if there&#x27;s a filter
//     if (filter) {
//         const pattern = new RegExp(filter, &#x27;gi&#x27;)
//         listIds.forEach((item) =&gt; {
//             const compareItem = item.name.toLowerCase()
//             if (item.name.toLowerCase().match(pattern)) {
//                 activeList.push(item)
//             }
//         })
//     }
//     // Output zero or more things
//     const itemCount = Math.min(5, activeList.length)
//     for (let i = 0; i &lt; itemCount; i++) {
//         const newItem = document.createElement(&#x27;button&#x27;)
//         newItem.id = `item--${activeList[i].id}`
//         newItem.innerHTML = activeList[i].name
//         itemWrapper.appendChild(newItem)
//     }
// }

// const handleMenuClick = (event) =&gt; {
//     console.log(event.target.id)
//     idParts = event.target.id.split(&#x27;--&#x27;)
//     for (const listItem of listIds) {
//         if (idParts[1] === listItem.id) {
//             setActiveItem(listItem.name)
//             updateItems()
//         }
//     }
//     // updateItems(null)
//     // document.getElementById(&#x27;font-input-field&#x27;).contentEditable = false
//     // document.getElementById(&#x27;font-input-field&#x27;).contentEditable = true
//     // document.getElementById(&#x27;test-focus-target&#x27;).focus()
//     // document.getElementById(&#x27;font-input-field&#x27;).blur()
// }

// const handleMenuInput = (event) =&gt; {
//     console.log(event)
//     const textFilter = document
//         .getElementById(&#x27;font-input-field&#x27;)
//         .innerText.trim()
//     updateItems(textFilter)
// }

// const setActiveItem = (itemName) =&gt; {
//     console.log(`The new item is: ${itemName}`)
//     document.getElementById(&#x27;active-font&#x27;).innerText = itemName
//     document.getElementById(&#x27;font-input-field&#x27;).innerText = itemName
//     activeList.length = 0
//     activeFont = itemName
//     // See this: for the bounce here to fix the safari bug about
//     // things not bluring
//     document.getElementById(&#x27;font-input-field&#x27;).blur()
//     document.getElementById(
//         &#x27;tmp-focus-target-for-safari-fix&#x27;
//     ).contentEditable = true
//     document.getElementById(&#x27;tmp-focus-target-for-safari-fix&#x27;).focus()
//     document.getElementById(&#x27;tmp-focus-target-for-safari-fix&#x27;).blur()
//     document.getElementById(
//         &#x27;tmp-focus-target-for-safari-fix&#x27;
//     ).contentEditable = false
// }

// const handleKeyUp = (event) =&gt; {
//     // TODO: Handle escape
//     // TODO: Handle arrow keys
//     if (event.key.toLowerCase() === &#x27;enter&#x27;) {
//         console.log(&#x27;Caught enter&#x27;)
//         if (activeList[0]) {
//             setActiveItem(activeList[0].name)
//             updateItems()
//         }
//         document.getElementById(&#x27;font-input-field&#x27;).innerText = document
//             .getElementById(&#x27;font-input-field&#x27;)
//             .innerText.replaceAll(/\n/g, &#x27;&#x27;)
//     }
// }

const handleInputFocus = (event) =&gt; {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    event.target.innerText = &#x27;&#x27;
    const selectionsEl = document.getElementById(&#x27;selections&#x27;)
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    for (let i = 0; i &lt; 5; i++) {
        const newItem = document.createElement(&#x27;button&#x27;)
        newItem.id = `option--${options[i].key}`
        newItem.innerHTML = options[i].value
        newItem.className = &#x27;option--button&#x27;
        newItem.addEventListener(&#x27;focus&#x27;, handleButtonFocus)
        newItem.addEventListener(&#x27;blur&#x27;, handleButtonBlur)
        newItem.addEventListener(&#x27;click&#x27;, handleButtonClick)
        selections.appendChild(newItem)
    }
}

const handleButtonClick = (event) =&gt; {
    const selectionsEl = document.getElementById(&#x27;selections&#x27;)
    while (selectionsEl.firstChild) {
        selectionsEl.removeChild(selectionsEl.firstChild)
    }
    const parts = event.target.id.split(&#x27;--&#x27;)
    state.activeSelection = fullKeys[parts[1]]
    console.log(state.activeSelection)
    document.getElementById(
        &#x27;active-selection&#x27;
    ).innerText = `Active Selection: ${state.activeSelection}`
    document.getElementById(&#x27;selection-text-field&#x27;).innerText =
        state.activeSelection
}

const handleButtonFocus = () =&gt; {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
}

const handleButtonBlur = () =&gt; {
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    timeoutIdForBlurTransition = setTimeout(() =&gt; {
        const selectionsEl = document.getElementById(&#x27;selections&#x27;)
        while (selectionsEl.firstChild) {
            selectionsEl.removeChild(selectionsEl.firstChild)
        }
    }, 30)
}

const handleInputBlur = () =&gt; {
    console.log(&#x27;-- Input blur&#x27;)
    if (timeoutIdForBlurTransition) {
        clearTimeout(timeoutIdForBlurTransition)
    }
    timeoutIdForBlurTransition = setTimeout(() =&gt; {
        const selectionsEl = document.getElementById(&#x27;selections&#x27;)
        while (selectionsEl.firstChild) {
            selectionsEl.removeChild(selectionsEl.firstChild)
        }
        document.getElementById(
            &#x27;active-selection&#x27;
        ).innerText = `Active Selection: ${state.activeSelection}`
    }, 30)
}

// const handleBlur = (event) =&gt; {
//     event.target.innerText = activeFont
//     // if (timeoutIdFixForBlur) {
//     //     clearTimeout(timeoutIdFixForBlur)
//     // }
//     // timeoutIdFixForBlur = setTimeout(() =&gt; {
//     //     event.target.innerText = activeFont
//     //     let itemWrapper = document.getElementById(&#x27;menuItems&#x27;)
//     //     while (itemWrapper.firstChild) {
//     //         console.log(&#x27;x&#x27;)
//     //         itemWrapper.removeChild(itemWrapper.firstChild)
//     //     }
//     // }, 100)
// }

const kickoff = () =&gt; {
    console.log(`Kickoff: ${new Date().getTime()}`)
    // prepIds()
    document
        .getElementById(&#x27;selection-text-field&#x27;)
        .addEventListener(&#x27;focus&#x27;, handleInputFocus)
    document
        .getElementById(&#x27;selection-text-field&#x27;)
        .addEventListener(&#x27;blur&#x27;, handleInputBlur)

    // document
    //     .getElementById(&#x27;menuItems&#x27;)
    //     .addEventListener(&#x27;click&#x27;, handleMenuClick)
    // document
    //     .getElementById(&#x27;menuWrapper&#x27;)
    //     .addEventListener(&#x27;input&#x27;, handleMenuInput)
    // document
    //     .getElementById(&#x27;menuWrapper&#x27;)
    //     .addEventListener(&#x27;keyup&#x27;, handleKeyUp)

    // updateItems()
}

document.addEventListener(&#x27;DOMContentLoaded&#x27;, kickoff)
</code></pre>
             
                <h2>Deatils</h2>
                <ul>
                    <li>GOAL: [ ] Accepts an array of key-value pairs to use as selections</li> <li>GOAL: [ ] Filter selections based on text input</li> <li>GOAL: [ ] Proper accessability</li> <li>GOAL: [ ] Show autocompete when typing</li> <li>GOAL: [ ] Show first option in text area if autocomplete doesn't match exactly</li> <li>GOAL: [ ] Clicking enter selects first item</li> <li>GOAL: [ ] Tabbing to secondary selections</li> <li>GOAL: [ ] Hitting enter on a secondary selection chooses it</li> <li>GOAL: [ ] Clicking a secondary button selects it</li> <li>GOAL: [ ] Show the last select item as a placeholder when the field isn't focused</li> <li>GOAL: [ ] Ability to select a placeholder on load</li> <li>GOAL: [ ] Scrollable list of selections</li> <li>GOAL: [ ] Multiple instances on the same page</li>
                </ul>
                 
                <h2>Notes</h2>
                <ul>
                    <li>This is currnelyt a very naive approach to the matching selections. If the string in the input field matches anywhere in the item list it gets included.</li>
                </ul>
             
                <h2>TODO</h2>
                <ul>
                    <li>Dig through this for multiline suppression: https://stackoverflow.com/questions/6831482/contenteditable-single-line-input</li>
                </ul>
             
                <h2>References</h2>
                <ul>
                    <li><a href=""></a></li>
                </ul>
                

    </main>
    <footer>
      made by <a href="https://twitter.com/TheIdOfAlan">
      <br />
      who has a <a href="https://www.alanwsmith.com">website</a> and a
      <a href="https://podcast.alanwsmith.com/">podcast</a> <br />
      among other <a href="https://links.alanwsmith.com">things</a>
    </footer>
    <script src="/styles/prism.js"></script>
  </body>
</html>
